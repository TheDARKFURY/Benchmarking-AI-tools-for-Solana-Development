Here is a Solana program that implements the escrow system you described:

```rust
use solana_program::{   account_info::{next_account_info, AccountInfo},   entrypoint,   entrypoint::ProgramResult,   msg,   program::{invoke, invoke_signed},   program_error::ProgramError,   pubkey::Pubkey, }; use spl_token::{instruction, Account}; // Define the program's entry point entrypoint!(process_instruction); // Define the program's instruction handler fn process_instruction(   program_id: &Pubkey,   accounts: &[AccountInfo],   instruction_data: &[u8], ) -> ProgramResult {   // Decode the instruction data   let instruction = Instruction::unpack(instruction_data)?;   match instruction {     Instruction::CreateOffer {        offer_amount,        offer_token,        ask_amount,        ask_token,        party_two,     } => {        // Create an offer details account        let offer_details_account = next_account_info(accounts)?;        let offer_details = OfferDetails::new(           offer_amount,           offer_token,           ask_amount,           ask_token,           party_two,        );        offer_details_account.data.borrow_mut()[..].copy_from_slice(&offer_details.try_to_vec()?);        // Transfer offer_amount from party one's send_account to temp_account        let temp_account = next_account_info(accounts)?;        let party_one_send_account = next_account_info(accounts)?;        let party_one_receive_account = next_account_info(accounts)?;        invoke(           &instruction::transfer(             &party_one_send_account.key,             &temp_account.key,             offer_amount,             &[],           ),           accounts,        )?;        Ok(())     }     Instruction::AcceptOffer {        party_two,        send_account,        receive_account,     } => {        // Verify offer details account exists and is valid        let offer_details_account = next_account_info(accounts)?;        let offer_details = OfferDetails::try_from_slice(&offer_details_account.data.borrow())?;        if offer_details.party_two != party_two {           return Err(ProgramError::InvalidArgument);        }        // Transfer ask_amount from party two's send_account to party one's receive_account        let party_one_receive_account = next_account_info(accounts)?;        invoke(           &instruction::transfer(             &send_account.key,             &party_one_receive_account.key,             offer_details.ask_amount,             &[],           ),           accounts,        )?;        // Transfer offer_amount from temp_account to party two's receive_account        let temp_account = next_account_info(accounts)?;        invoke(           &instruction::transfer(             &temp_account.key,             &receive_account.key,             offer_details.offer_amount,             &[],           ),           accounts,        )?;        Ok(())     }     Instruction::CloseOffer => {        // Verify offer details account exists and is valid        let offer_details_account = next_account_info(accounts)?;        let offer_details = OfferDetails::try_from_slice(&offer_details_account.data.borrow())?;        // Transfer offer_amount from temp_account back to party one's receive_account        let temp_account = next_account_info(accounts)?;        let party_one_receive_account = next_account_info(accounts)?;        invoke(           &instruction::transfer(             &temp_account.key,             &party_one_receive_account.key,             offer_details.offer_amount,             &[],           ),           accounts,        )?;        Ok(())     }   } } // Define the OfferDetails struct #[derive(BorshDeserialize, BorshSerialize)] struct OfferDetails {   offer_amount: u64,   offer_token: Pubkey,   ask_amount: u64,   ask_token: Pubkey,   party_two: Pubkey, } impl OfferDetails {   fn new(     offer_amount: u64,     offer_token: Pubkey,     ask_amount: u64,     ask_token: Pubkey,     party_two: Pubkey,   ) -> Self {     OfferDetails {        offer_amount,        offer_token,        ask_amount,        ask_token,        party_two,     }   } } // Define the Instruction enum #[derive(BorshDeserialize, BorshSerialize)] enum Instruction {   CreateOffer {     offer_amount: u64,     offer_token: Pubkey,     ask_amount: u64,     ask_token: Pubkey,     party_two: Pubkey,   },   AcceptOffer {     party_two: Pubkey,     send_account: Pubkey,     receive_account: Pubkey,   },   CloseOffer, } impl Instruction {   fn unpack(instruction_data: &[u8]) -> Result<Self, ProgramError> {     let instruction = Instruction::try_from_slice(instruction_data)?;     Ok(instruction)   } }
```

This program defines three instructions: `CreateOffer`, `AcceptOffer`, and `CloseOffer`. The `CreateOfferinstruction` creates an offer details account and transfers the offer amount from the party one's send account to a temporary account controlled by a PDA. The `AcceptOffer` instruction verifies the offer details account and transfers the ask amount from the party two's send account to the party one's receive account, and then transfers the offer amount from the temporary account to the party two's receive account. The `CloseOffer` instruction transfers the offer amount from the temporary account back to the party one's receive account.
Note that this program uses the `spl_token` crate to interact with the SPL token program, and the `solana_programcrate` to interact with the Solana program runtime. The program also uses the borsh crate to serialize and deserialize the OfferDetails struct and the Instruction enum.
To deploy this program, you will need to create a Solana program ID and deploy the program to the Solana blockchain using the solana program deploy command. You will also need to create a PDA to act as the authority for the temporary account.
Once the program is deployed, you can use the solana program invoke command to call the program's instructions. 

For example, to create an offer, you would use the following command:

```bash
solana program invoke <program_id> CreateOffer <offer_amount> <offer_token> <ask_amount> <ask_token> <party_two>
```

Similarly, to accept an offer, you would use the following command:

```bash
solana program invoke <program_id> AcceptOffer <party_two> <send_account> <receive_account>
```

And to close an offer, you would use the following command:

```bash
solana program invoke <program_id> CloseOffer
```